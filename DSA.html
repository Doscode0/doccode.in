<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="DSA.css">
  <title>DSA NOTE</title>
  <link rel="icon" type="image" href="icon.jpeg">
</head>
<body>
  <div class="search-wrapper">
    <label for="search">Search Users</label>
    <input type="search" id="input" placeholder="Available soon...." onkeyup="searchFunction()">
  </div>
  <div class="user-cards" data-user-cards-container=""></div>
  <template data-user-template>
    <div class="card">
      <div class="header" data-header></div>
      <div class="body" data-body></div>
    </div>
  </template>
  <div class="content-container" id="content">

  <h4 id="p">1)DATA:</h4>
 


Data is a collection of row facts and information.

<h4 id="p">2)DATA STRUCTURE:</h4>
Organised collection of data in particular format called data structure.data structure is a technique or method of study how the data are interrelated to each other logically or mathematically.
<h4 id="p">3)PURPOSE OF DATA STRUCTURE:</h4>
The main aim of data structure is to increase the efficiency of program and decrease the storage requirement.
<h4 id="p"> 4)CLASSIFICATION OF DATA STRUCTURE:</h4>
<pre>a)linear :         
    (i)graph                    
    (ii)linked list            
    (iii)stack
    (iv)queue

        OR

non linear :
     (i)array
     (ii)tree

b)homogenous :
     (i)array  

        OR

non homogenous
     (i)structure
     (ii)union

c)static :
(i)char a[10]

        OR

dynamic :
(i)*a
</pre>

<h4 id="p">5)WHAT IS ALGORITHIM ?</h4>

The step by step description of any program in general language is called algorithim.

<pre>         OR </pre>

 algorithim is a sequence of an clear instruction used to solving a problem .such a way that it can implimented as a program for computer.

 <h4 id="p" >6)CHARACTERISTICS OF ALGORITHIM</h4>
 <pre>
a)input-o or more well defined inputs
b)output-must generate atleast one output
c)umambigious/definiteness
d)finiteness
e)effectiveness
 </pre>
<h4 id="p">7)DATATYPE AND ITS TYPE:</h4>
datatype is a type of data which is used in the program.In other word we can say that it is used to declare a variable.
<pre>            OR </pre>
datatype specify how we entered data in our program and what type of data we entred.

<h5>ITS TYPE</h5>
<pre>
i)Primary datatype<br>
ii)Secondary datatype

primary datatype :-

                  SIZE
                --------
Int     -        2 bytes  
char    -        1 bytes
float   -        4 bytes
void    -        no size


secondary datatype :-

1)Array
2)Pointer
3)Structure
4)Union</pre>

<h4>8)ABSTRAC DATA TYPE:</h4>

Mathematically model of data objects that make up a data type as well as the functions that operate these objects.
<br>

ex--lists,graph,array along with their objects(abstrac datatype)


<h4>DIFFERENCE BETWEEN LINEAR AND NONLINEAR</h4>

<pre>
  9) 
  LINEAR DATA STRUCTURE         |        NON LINEAR DATA STRUCTURE
  ______________________________|_______________________________________
i>In this data structure The    |i>In the data structure data is organaised
 elements are organised in      | without any sequence..
 a sequence such as..           |
    ex- array,srack etc         | ex-tree,graph etc
ii>In linear data structure     |ii>In non linear d.s multiple
single level is involved.       | levels are  involved.                               |  
iii>it is easy to implement.    |iii>it is difficult to implement.
iv>data element can transfered  |iv>data elements cannot be treversed in 
 in a single run only.          | single run only.
v>memory is not utiliged in a   | v>memory utiligation in an efficient
efficient way.                  |  way.
                              
</pre>
<h4>10)DATA STRUCTURE:</h4>

Data structure is of two types there are <br> i) Primitive( ex-int,float,char,double)<br>
<br>
ii) Non primitive
<br>
<br>
Non primitive data structure is of two types <br> 1)Linear <br>
ii)Non-linear
<br>
<br>
Linear d.s is of two types (i.e :- static,dynamic)<br<br>
Non-linear d.s is of two types (i.e :- tree,graph)
<h4>11)ALGORITHIM COMPLEXITY:-</h4>
Algorithim complexity refers to the analysis of an algorithim performance in term of time and space requirement as a function of input size.
<h4>12)SPACE COMPLEXITY:-</h4>
Total amount of memory required by an algorithim for its complete execution called space complexity
<h4>13) CONSTANT SPACE COMPLEXITY:-</h4>
If any algorithim requires fixed amount of space then the space complexity is called constant space complexity.
<pre>
  Ex - int sqrt(int n){
    return n*n;
    }
</pre>
<h4>14)LINEAR SPACE COMPLEXITY</h4>
If the amount of space required by algorithim is increase of input values then that space complexity is called linear space complexity.
<pre>
  EX-int sum(int arr[],int n){
    int sum=0;
    for(int sum i=0;i<=n;i++)
         {
            sum=sum+arr[i];
          }
    return sum;
    }
</pre>
<h4>15) TIME COMPLEXITY:-</h4>
Total amount of time required by an algorithim to its complete execution called time complexity.
<h4>16) CONSTANT SPACE COMPLEXITY</h4>
If any algorithim required fixed amount of space then the space complexity which said to be const space complexity.
<pre>
  Ex-
  int sqrt(int n)
    {
      return n*n;
     }
</pre>
<h4>17)LINEAR TIME COMPLEXITY:</h4>
If the amount of space required by algorithim is increase of input values then that space complexity is called linear space complexity.
<pre>
  int sum(int a[],int n)
  {
    int sum=0;
    for (int i=0;i< n;i++)
      {
        sum=sum+a[i];
       }
    return sum;
  }
</pre>
<h4>18)DATA SPACE:</h4>
It is the amount of memory use to store all the variable and constant.
<h4>19)ARRAY</h4>
a)Array is derived data type which is constured by the help of primitive  data type.
b)Array is a variable which store more than one values of same data types in a continuous memory location.
<h4>20)LINEAR ARRAY</h4>
-A linear array is a list of a finite number n of homogenous data elements(i.e:- data element of same time )such that -
  a)The elements of the array are referenced respetively by an index set consecutive numbers.
  b)The elements of the array are stored respetively in successive memory location.
<h4>21)DIFFERENT TYPES OF OPERATION IN ARRAY LINEAR DATA STRUCTURE</h4>
<pre>
  a)TRAVERSAL:- 
  I)Processing each element in list.
  II)search finding the location of element finding the location of element with a given value.

b)INSERTION:-
  -Adding new element of list

c)DELETION:-
  -Removing elements from list.

d)SORTING:-
  -Arranging the elements in sum type of order.

E)MERGING:-
  -Combining to list to be a single list.
</pre>
<h4>22)TRAVERSING IN A LINEAR ARRAY </h4>
<pre>
  i)[Initialige counter] set K=LB. 
  ii)Repeat steps 3 and 4 while K< UB.
  iii)[Visit elements apply process to linear array of [K]].
  iv)[Increase the counter]  set K <- K++
  v)[End of stop 2 loop].
  vi)Exist.
</pre>
<h4>23.INSERTION IN LINEAR ARRAYS</h4>
<pre>
  -Here LA is a linear array with  N elements and K is a positive intiger. such that K< N This algorithm inserts an element item into the Kth position in LA. 
 I)[Intialge counter] set J=N.
 II)Repeat step 3&4 while J>K.
 III)[Move jth element downward]
     Set LA[J+1]=LA[J]
 IV)[Decrease counter] Set J=J-1
    [End of step 2 loop]
 V)[Insert element set LA[K]= ITEM
 VI)[Rest N] Set N=NH
 VII)EXIT.
</pre>

<h4>23.INSERTION IN LINEAR ARRAYS CODE</h4><pre>
#include<  stdio.h>
  int insertion(int arr[],int size,int element, int capacity,int index)
  {
      if(size>=capacity)
      {
          return -1;
      }
      else{
          for(int i=size-1;i>=index;i--)
          {
              arr[i+1]=arr[i];
          }
          arr[index]=element;
          return 1;
      }
  }
  int main()
  {
      int n,arr[100];
      printf("Enter the size of array:- ");
      scanf("%d",&n);
      printf("Enter the array elements:- ");
      for(int i=0;i< n;i++)
      {
          scanf("%d",&arr[i]);
      }
      printf("Enter the adding index number:- ");
      int index,element;
      scanf("%d",&index);
      printf("Enter adding element:- ");
      scanf("%d",&element);
      insertion(arr,n,element,100,index);
      n +=1;//n=n+1;
      // for display result .....
      printf("Inserted array is :- ");</pre><pre>
        for(int i=0;i< n;i++)
      {
          printf("%d",arr[i]);
      }
      return 0;
  }
      </pre> </pre>
<h4>24)DELETION FROM ARRAYS</h4>
        <pre>       DELETE(A,N,k,ITEM)
 1. Step-1:Start
 2. Step-2: set ITEM=a[k]
 3. Step-3: Repeat for J=K to N-1
       set A[J]=a[j+1]
      [End the loop]
  4. Step-4: Set N=N-1
  5. Step-5: Exit.</pre>

</div>
<h4>25)DELETION FROM ARRAYS CODE</h4>

<pre>#include< stdio.h>
  int delection(int arr[],int size,int index)
  {
      for(int i=index;i< size-1;i++)
      {
          arr[i]=arr[i+1];
      }
  }
  int main()
  {
      printf("Enter array size:- ");
      int n;
      scanf("%d",&n);
      int arr[n];
      printf("Enter the array element:- ");
      for(int i=0;i< n;i++)
      {
          scanf("%d",&arr[i]);
      }
      printf("Enter the delete index:- ");
      int index;
      scanf("%d",&index);
      delection(arr,n,index);
      n -=1;// n=n-1;
      //  for see the changes simplely print the array
      for(int i=0;i< n;i++)
      {
          printf("%d ",arr[i]);
      } return 0;
  }</pre>
  <h4>26)BUBBLE SORT</h4>
  DEFINATION:- <br>
  -------------------<br>

    bubble sort arrange N number of array  elements by plaing the biggest element on proper position.It always arrange data in descending order.<br>
  
  ex-a[5]={7,6,3,9,0}<br>
  
  OUTPUT:-{0,3,6,7,9}
  <br><br>
  ALGORITHAM:-<br>
  ----------------------<br>
  <pre>1. Step-1:  Begin
    2. Step-2:  Input a[5] 
    3. Step-3:  Set 1 <- 3  //(i=3) {Note:- In algoritham don't use '='. Always use <- for set item value}
    4. Step-4:  Repeat step 4 & 9  While(i>=0)
    5. Step-5:  Set j <- 0 	//(j=0)
    6. Step-6:  Repeat step 3 & 8  While(j<=i)
    7. Step-7:  if(a[j]>a[j+1])
          Set temp<- a[i]
              a[j] <- a[j+1]
        a[j+1] <-temp
    8. Step-8:  j <- j+1
    9. Step-9:  i<-i-1
    10. Step-10:  print a[5]
    11. Step-11:  Exist.
    </pre>
  
    <h4>27)BUBBLE SORT CODE</h4>
    <pre>
      #include< stdio.h>
      void bubble(int arr[],int n);
      int main()
      {
          int n;
          printf("Enter the size of array:- ");
          scanf("%d",&n);
          int arr[n];
          printf("Enter array elements:- ");
          for(int i=0;i< n;i++)
          {
              scanf("%d",&arr[i]);
          }
          bubble(arr,n);
          /*Now you print the array to see changes*/
          for(int i=0;i< n;i++)
          {
              printf("%d",arr[i]);
          }
          return 0;
      }
      void bubble(int arr[],int n)
      {
          for(int i=0;i< n-1;i++)
          {
              for(int j=0;j< n-1-i;j++)
              {
                  if(arr[j]>arr[j+1])
                  {
                      int satya = arr[j];/* you can also take 'temp' in place of satya*/
                      arr[j] = arr[j+1];
                      arr[j+1] = satya;
                  }
              }
          }
      }</pre>
  
<h4>28)LINEAR SEARCH</h4>
DEFINATION:- <br>
--------------------<br>
It is a very basic and simple search an element in given array by travesing the any from the starting till the disred element is found.<br>
<br>
ALGORITHM:-<br>
--------------------<br>
<pre>1.Step-1: Begin
  2.Step-2: Set a[5] <- {10,20,30,40,50}
  3.Step-3: Set i <- 0
  4.Step-4: Input searching item
  5.Step-5: Repeat step 6 & 7 while(i<5)
  6.Step-6: if a[i]=item then
      print item found & location = i & exist
  7.Step-7: Set i <- i+1
  8.Step-8: if j>=5 then 
      print item not found
  9.Step-9: End.
</pre>
<h4>29)LINEAR SEARCH CODE</h4>

<pre>#include< stdio.h>
  int main()
  {
      int n;
      printf("Enter the array size:- ");
      scanf("%d",&n);
      printf("Enter the array element:- ");
      int arr[n];
      for(int i=0;i< n;i++)
      {
          scanf("%d",&arr[i]);
      }
      printf("Enter the searching element:- ");
      int item;int loc=0;
      scanf("%d",&item);
      for(int i=0;i< n;i++)
      {
          if(arr[i]==item)
          {
               printf("Searching item is available and index is %d ",i);
              loc = loc + 1;
          }
      }
      if(loc==0)
      {
           printf("searching item is not available...");
      }
      return 0;
  }</pre>

<h4>30)BINARY SEARCH</h4>
It is the devide an conquer searching technique in which we have to arrage the data in particular format before searching operation .After that we find the middle element of array an campare with target element(searching element).<br>
If item is not found the we again cheak the target elements is greater than or less than middle element, if it greater than we search right side of middle element otherwise left side of middle element.<br><br>
ALGORITHM:-<br>
-------------------
<br>
<pre>Step-1: Begin
Step-2: Set a[5] <- {10,20,30,40,50)
Step-1: Set lr <- 0 , up <- 4 , f <- 0
Step-3: Input searching item
Step-4: Reapet (6) & (8) while (lr <= up)
Step-5: Set mid <- (lr+up)/2
Step-6: If a[mid] = item then set f <- 1 & break
Step-7: If a[mid] < item then set lr <- mid+1 
                  else
    set up <- mid-1
Step-8: If f=1 then
      print item found with loc = mid
          else
       print not found
Step-9: Exist. </pre>


<h4>31)BINARY SEARCH CODE</h4>


<pre>#include< stdio.h>
  int binarysearch(int arr[],int size,int item);
  int main()
  {
      int n;
      printf("Enter the array size:- ");
      scanf("%d",&n);
      int lr=0;int up=n-1;
      int arr[n];
      printf("Enter the array element in Ascending Order:- ");
      for(int i=0;i< n;i++)
      {
          scanf("%d",&arr[i]);
      }
      printf("Enter the searching item:- ");
      int item;
      scanf("%d",&item);
      int bs=binarysearch(arr,n,item);
      if(bs==-1)
      {
          printf("no");
      }
      else{
          printf("yes and Location is %d",bs);
      }
      return 0;
  }
  int binarysearch( int arr[],int size,int item)
  {
      int lr=0,up=size-1;// here lr is lower and up is upper
      int f=0;int mid;
      while(lr<=up)
      {
          mid=(lr+up)/2;
          if(arr[mid]==item)
          {
              return mid;
          }
          if(arr[mid< item])
          {
              lr=mid+1;
          }else{
              up=mid-1;
          }
          return -1;
      }
  }
</pre>
<h4>32)SPARSE MATRIX</h4>
sparse matrices are those matrices which have the majority of their elements equal to zero.

<h4>33)SPARSE MATRIX CODE</h4>
<pre>#include< stdio.h>
  int main(){
      int arr[3][3];
      printf("Enter the matrix number");
      for(int i=0;i< 3;i++)
      {
          for(int j=0;j< 3;j++)
          {
              scanf("%d",&arr[i][j]);
          }
      }
      /*IT is use for to see the input matrix it is not necessary if you want to see input matrix then write */
      printf("\nInput matrix is\n");
      for(int i=0;i< 3;i++)
      {
          for(int j=0;j< 3;j++)
          {
              printf("%d ",arr[i][j]);
          }printf("\n");
      }
      int count=0;int z=0, nz=0;/* here z= zero ,nz= none zero  */
      for(int i=0;i< 3;i++)
      {
          for(int j=0;j< 3;j++)
          {
              if(arr[i][j]==0)
              {
                  z +=1;// z++
              }else{
                  nz +=1;//  nz++
              }
          }
      } int sparse[nz][z]; int k=0;
       if(nz>z)
          {
              printf("\nNot a sparse matrix:- ");
          }
          else{
              for(int i=0;i< 3;i++)
              {
                  for(int j=0;j< 3;j++)
                  {
                      if(arr[i][j]!=0)
                      {
                          sparse[k][0]=i;
                          sparse[k][1]=j;
                          sparse[k][2]=arr[i][j];
                          k++;
                          /*Now print the sparse matrix*/
                      }
                  }
              }
          } printf("\nsparse matrix is:- \n");
                       for(int i=0;i< nz;i++)
                      {
                          for(int j=0;j< 3;j++)
                          {
                            printf("%d ",sparse[i][j]);
                          }printf("\n");
                      }return 0;
  }</pre>
  <h4>34)WHAT IS INFIX AND POSTFIX ?</h4>

  <h4>35)INFIX TO POSTFIX USING STACK CODE</h4>
  <pre>#include < stdio.h>
    #include < stdlib.h>
    #include < string.h>
     
    struct stack
    {
        int size;
        int top;
        char *arr;
    };
     
    int stackTop(struct stack* sp){
        return sp->arr[sp->top];
    }
     
    int isEmpty(struct stack *ptr)
    {
        if (ptr->top == -1)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
     
    int isFull(struct stack *ptr)
    {
        if (ptr->top == ptr->size - 1)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
     
    void push(struct stack* ptr, char val){
        if(isFull(ptr)){
            printf("Stack Overflow! Cannot push %d to the stack\n", val);
        }
        else{
            ptr->top++;
            ptr->arr[ptr->top] = val;
        }
    }
     
    char pop(struct stack* ptr){
        if(isEmpty(ptr)){
            printf("Stack Underflow ! Cannot pop from the stack\n");
            return -1;
        }
        else{
            char val = ptr->arr[ptr->top];
            ptr->top--;
            return val;
        }
    }
    int precedence(char ch){
        if(ch == '*' || ch=='/')
            return 3;
        else if(ch == '+' || ch=='-')
            return 2; 
        else
            return 0;
    }
     
    int isOperator(char ch){
        if(ch=='+' || ch=='-' ||ch=='*' || ch=='/') 
            return 1;
        else
            return 0;
    }
    char* infixToPostfix(char* infix){
        struct stack * sp = (struct stack *) malloc(sizeof(struct stack));
        sp->size = 10; 
        sp->top = -1;
        sp->arr = (char *) malloc(sp->size * sizeof(char));
        char * postfix = (char *) malloc((strlen(infix)+1) * sizeof(char));
        int i=0; 
        int j = 0; 
        while (infix[i]!='\0')
        {
            if(!isOperator(infix[i])){
                postfix[j] = infix[i];
                j++;
                i++;
            }
            else{
                if(precedence(infix[i])> precedence(stackTop(sp))){
                    push(sp, infix[i]);
                    i++;
                }
                else{
                    postfix[j] = pop(sp);
                    j++;
                }
            }
        }
        while (!isEmpty(sp))    
        {
            postfix[j] = pop(sp);
            j++;
        }
        postfix[j] = '\0';
        return postfix;
    }
    int main()
    {
        char infix[100];
        printf("Enter the expression:- ");
        scanf("%s",infix);
        printf("postfix is %s", infixToPostfix(infix));
        return 0;
    }
    </pre>
<h4>36)STACK</h4>
 i)A Stack is an ordered collection of homogenous data elements, Where the insertion and deletion take place at one end know as top.<br>
 ii)The Stack also called as LIFO(last in first out).Its means the element which is inserted last must be delected first.
 <h4>37)WRITE A ALGORITHAM FOR PUSH OPERATION USING STACK</h4>
 <pre>STEP-1:- Begin
    STEP-2:- if Top = N Then 
           print "Overflow & Exit"
    STEP-3:- input new item
    STEP-4:- Top=Top+1
    STEP-5:- stack[Top] <- item
    STEP-6:- exit.</pre>
    <h4>38)WRITE A ALGORITHAM FOR POP OPERATION USING STACK</h4>
    <pre>STEP-1:- Begin
        STEP-2:- if Top = -1 Then 
               print "Overflow & Exit"
        STEP-3:- set item <- stack[Top]
        STEP-4:- Top <- Top-1
        STEP-5:- print "item deleted"
        STEP-6:- exit.
        </pre>
    <h4>39)PUSH AND POP CODE USING STACK</h4>
    <pre>#include< stdio.h>
        #define MAX_SIZE 5
        int stack[MAX_SIZE];
        int top = -1;
        void push(int item){
            if(top==MAX_SIZE-1){
                printf("Overflow ! & Exit\n");
            }else{
                stack[++top] = item;
                printf("%d Item Inserted.\n",item);
            }
        }
        void pop(){
            if(top == -1)
            {
                printf("Underflow & Exit\n");
            }else{
                int Item = stack[top--];
                printf("%d Item DEleted.\n",Item);
            }
        }
        void display(){
            if(top == -1){
                printf("The stack is empty");
            }else{
                printf("stack element:- ");
                for(int i=0;i<= top;i++){
                    printf("%d ",stack[i]);
                }printf("\n");
            }
        }
        int main()
        {
            int choice,item;
            printf(" 1.Push\n 2.Pop\n 3.Display\n 4.Exit\n");
            while (1)
            {
                printf("Enter your choice:- ");
                scanf("%d",&choice);
               switch(choice)
               {
                case 1:
                {
                    printf("Enter value to Push:- ");
                    scanf("%d",&item);
                    push(item);break;
                }
                case 2:
                {
                    pop();break;
                }
                case 3:
                {
                    display();break;
                }
                case 4:
                {
                    return 0;
                }
                default :{
                    printf("Invalid choice...\n");
                }
        
               }
            }
            return 0;
        }</pre><br><br>
    <br><br>

        <pre>__________________________________________</pre>
        <pre>|             UNIT-1 completed            |  </pre><pre>|_________________________________________|</pre>

        <pre>             Thank you </pre><br>
  <h3>Join Us In WhatsApp...To Know All Update</h3>
  <a href="https://chat.whatsapp.com/EXHLJO97dzzDxYOS4HiEgK">https://chat.whatsapp.com/EXHLJO97dzzDxYOS4HiEgK</a><br><br><br>
</body>
</html>